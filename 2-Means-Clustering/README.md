# 2-Means-Clustering

## Introduction:
This design performs clustering on a 2-dimensional variable-size data set consisting of pairs of 32-bit (unsigned) integers (X, Y) and returns two 2D centroids representing the distribution of the data set. A B-RAM IP-core is implemented internally to store and operate upon the data set. The implementation performs integer-division and provides integer-level precision. A validation script in python has been provided to compute the centroids of the data set and compare them with the ones returned by the FPGA.

## Dependencies
* UART transceiver core module: uart_transceiver.v (Sebastien Bourdeauducq)
* RS-232 driver module: RS232_UART.c & RS232_UART.h (Teunis van Beelen)
* True Dual-Port BRAM IP-Core: VLNV: xilinx.com:ip:blk_mem_gen:8.4 (Xilinx)
* Datasets generated on [generatedata.com](https://www.generatedata.com).
* External libraries imported in python validation module: numpy and matplotlib

## Implementation Details
* All the numbers are in a 32-bit unsigned integer format and are represented as std_logic_vectors (except for the internal variables) within the FSMs.
* Calculations are implemented in this design using integer division. Therefore, the results have integer-level precision.
* Each data-point is a tuple of two 32-bit unsigned integers (*x*, *y*).
* The tuples are processed serially and are stored consecutively in the memory. The order of processing and storage is: *x*<sub>1</sub>, *y*<sub>1</sub>, *x*<sub>2</sub>, *y*<sub>2</sub>, ..., *x*<sub>n</sub>, *y*<sub>n</sub>.

### Input
* The first input to the programme is the size of the dataset (*n*), i.e. the number of data-points in the dataset.
* This is followed by 2*n* values corresponding to the data-points serially fed as (*x*, *y*) pairs: *x*<sub>1</sub>, *y*<sub>1</sub>, *x*<sub>2</sub>, *y*<sub>2</sub>, ..., *x*<sub>n</sub>, *y*<sub>n</sub>.

### Output
* The output consists of a pair of tuples reresenting the connverged centroids, *C<sub>1</sub>* & *C<sub>2</sub>*, serially returned as *x*<sub>1</sub>, *y*<sub>1</sub>, *x*<sub>2</sub>, *y*<sub>2</sub>.

### Modular Organization
* The Int32CommUtil (Communications and Utility for 32-bit integer processing) module is the primary FSM which drives the functionality of the programme and it instantiates the modules of the other entities, viz. UART, BRAM and 2-Means.
* The UART module interfaces the UART Transceiver Module with the Driver module and debounces the signal that may interfere with the transmission.
* The BRAM module is generated by the Synthesis Environment and provides the functionality of a True Dual-port Block RAM.
* The 2-Means module is the process block which implements the unsupervised classification algorithm.
* The Int32CommUtil module instantiates the BRAM unit. Port-A of the BRAM unit is interfaced with the Int32CommUtil module while the Port-B is interfaced with the process block (2-Means module).
* In the default state, the Int32CommUtil driver activates the UART and BRAM modules, and waits for input. It reads the input and stores the dataset into the BRAM.
* Once the dataset has been recorded, it activates the process block (2-Means module) and suspends all the other processes while it waits fot the process block to yield. The boundary of the dataset are designated by providing the starting and the ending addresses to the process block.
* The 2-Means module implements the K-means algorithm on the dataset. The centroids are initialized to the hard-coded values: (1, 1) & (24, 24). The resulting converged centroids are returned to the driver module by overwriting them onto the first two data-points of the dataset in the BRAM. The process block triggers a *done* signal to indicate to the driver module that the process has been completed.
* In the final state, the driver module reads the first four values in the BRAM and serially returns these converged centroids over the UART transceiver to the computer.
* The programme running on the computer reads the dataset from the *CustomData.dat* file and feeds it to the FPGA board over the UART transceiver. Two test datasets have been generated and stored in the *Datasets* directory.
* A Python validation script has been provided which calculates the centroids based on the selected dataset and validates them against the centroids obtained from the FPGA board. It also generates a plot comparing the two results. The validation script is automatically triggered at the end of the main programme.
